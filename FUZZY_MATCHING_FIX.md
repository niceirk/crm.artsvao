# Исправление обнаружения конфликтов при двусторонней синхронизации

## Проблема

При двусторонней синхронизации справочников (типы мероприятий и помещения) между CRM и Pyrus возникала ситуация, когда:
- В CRM есть запись "акция1"
- В Pyrus есть запись "акция"
- Система НЕ обнаруживала конфликт и создавала дубли в обеих системах

### Почему это происходило?

Старая логика сравнивала названия **только по точному совпадению** (case-insensitive):
```typescript
// Старый код - только точное сравнение
existingEventType = await this.prisma.eventType.findFirst({
  where: {
    name: {
      equals: eventTypeName,  // "акция" !== "акция1"
      mode: 'insensitive',
    },
  },
});
```

Результат:
1. При синхронизации Pyrus → CRM: "акция" не найдена в CRM → создается новая запись "акция"
2. При синхронизации CRM → Pyrus: "акция1" не найдена в Pyrus → создается новая запись "акция1"
3. **Итог:** Дубли в обеих системах вместо обнаружения конфликта

## Решение

Добавлен **fuzzy matching** (нечеткое сравнение) для обнаружения похожих названий.

### Что добавлено?

#### 1. Функция вычисления схожести строк

Использует **алгоритм Levenshtein distance**:

```typescript
function stringSimilarity(str1: string, str2: string): number {
  // Возвращает значение от 0 (полностью разные) до 1 (идентичные)

  // Особый случай: если одна строка содержит другую
  if (s1.includes(s2) || s2.includes(s1)) {
    return 0.8; // Высокая схожесть (80%)
  }

  // Levenshtein distance для остальных случаев
  // ...
}
```

**Примеры схожести:**
- "акция" и "акция1" → **0.8** (80% - одна строка содержит другую)
- "концерт" и "консерт" → **0.875** (87.5% - опечатка в одной букве)
- "семинар" и "вебинар" → **0.625** (62.5% - ниже порога)

#### 2. Обнаружение похожих названий при синхронизации

Добавлена проверка на похожие названия с порогом схожести **75%**:

```typescript
const SIMILARITY_THRESHOLD = 0.75; // Порог схожести (75%)

// Если не найдено по точному совпадению, ищем похожие
if (!existingEventType) {
  const allEventTypes = await this.prisma.eventType.findMany();

  for (const candidate of allEventTypes) {
    const similarity = stringSimilarity(eventTypeName, candidate.name);
    if (similarity >= SIMILARITY_THRESHOLD) {
      // ПОТЕНЦИАЛЬНЫЙ ДУБЛЬ ОБНАРУЖЕН!
      this.logger.warn(
        `⚠️  ПОТЕНЦИАЛЬНЫЙ ДУБЛЬ: "${eventTypeName}" (Pyrus) похож на "${candidate.name}" (CRM) ` +
        `(схожесть: ${(similarity * 100).toFixed(0)}%)`
      );
      // Пропускаем создание дубля
      continue;
    }
  }
}
```

#### 3. Применение ко всем методам синхронизации

Fuzzy matching добавлен в 4 метода:

1. **`syncEventTypesFromCatalog`** (Pyrus → CRM)
   - Обнаруживает, если в CRM уже есть похожий тип мероприятия

2. **`syncEventTypesToPyrus`** (CRM → Pyrus)
   - Обнаруживает, если в Pyrus уже есть похожий тип мероприятия

3. **`syncRoomsFromCatalog`** (Pyrus → CRM)
   - Обнаруживает, если в CRM уже есть похожее помещение

4. **`syncRoomsToPyrus`** (CRM → Pyrus)
   - Обнаруживает, если в Pyrus уже есть похожее помещение

## Как теперь работает синхронизация?

### Сценарий 1: Точное совпадение
```
CRM:   "Концерт"
Pyrus: "Концерт"
→ Объекты связываются через pyrusId, данные синхронизируются
```

### Сценарий 2: Похожие названия (схожесть ≥ 75%)
```
CRM:   "акция1"
Pyrus: "акция"
→ ⚠️  ПОТЕНЦИАЛЬНЫЙ ДУБЛЬ обнаружен!
→ Создание дубля пропущено
→ Ошибка добавлена в result.errors для уведомления пользователя
```

### Сценарий 3: Разные названия (схожесть < 75%)
```
CRM:   "Концерт"
Pyrus: "Семинар"
→ Разные объекты, оба создаются/синхронизируются независимо
```

## Что видит пользователь?

### В логах сервера:
```
[PyrusService] ⚠️  ПОТЕНЦИАЛЬНЫЙ ДУБЛЬ: Тип мероприятия в Pyrus "акция" похож на существующий в CRM "акция1" (схожесть: 80%).
Рекомендуется проверить вручную. Пропускаем создание дубля.
```

### В результате API запроса:
```json
{
  "created": 5,
  "updated": 10,
  "errors": [
    "Потенциальный дубль: \"акция\" (Pyrus) похож на \"акция1\" (CRM)"
  ]
}
```

## Тестирование

### 1. Тест на обнаружение похожих названий

```bash
# В CRM создайте тип мероприятия "Акция основная"
# В Pyrus создайте тип мероприятия "акция"

# Выполните синхронизацию
curl -X POST http://localhost:3000/integrations/pyrus/sync-event-types-bidirectional \
  -H "Authorization: Bearer $TOKEN"

# Ожидаемый результат:
# - В логах появится предупреждение ⚠️  ПОТЕНЦИАЛЬНЫЙ ДУБЛЬ
# - Дубль НЕ будет создан
# - В errors будет сообщение о похожих названиях
```

### 2. Проверка порога схожести

| Название в CRM | Название в Pyrus | Схожесть | Результат |
|---------------|------------------|----------|-----------|
| "акция1" | "акция" | 80% | ⚠️ Дубль обнаружен |
| "концерт" | "консерт" | 87.5% | ⚠️ Дубль обнаружен |
| "семинар" | "вебинар" | 62.5% | ✅ Разные объекты |
| "Зал 1" | "Зал1" | 80% | ⚠️ Дубль обнаружен |
| "Театральный зал" | "Зал театральный" | ~70% | ✅ Разные объекты |

## Настройка порога схожести

Если нужно изменить порог обнаружения дублей, измените константу в `pyrus.service.ts`:

```typescript
const SIMILARITY_THRESHOLD = 0.75; // 75% по умолчанию

// Более строгий (меньше ложных срабатываний):
const SIMILARITY_THRESHOLD = 0.85; // 85%

// Более мягкий (больше обнаружений):
const SIMILARITY_THRESHOLD = 0.65; // 65%
```

## Рекомендации

1. **Регулярно проверяйте логи** на наличие предупреждений о потенциальных дублях
2. **Используйте единообразное именование** в обеих системах для минимизации конфликтов
3. **При обнаружении дубля:**
   - Проверьте вручную, действительно ли это дубль
   - Если да - удалите один из объектов
   - Если нет - переименуйте один из объектов так, чтобы схожесть была < 75%
4. **Используйте preview endpoints** перед синхронизацией:
   - `GET /integrations/pyrus/preview-event-types-sync`
   - `GET /integrations/pyrus/preview-rooms-sync`

## Связанные API endpoints

### Синхронизация типов мероприятий
- `POST /integrations/pyrus/sync-event-types` - Pyrus → CRM
- `POST /integrations/pyrus/sync-event-types-to-pyrus` - CRM → Pyrus
- `POST /integrations/pyrus/sync-event-types-bidirectional` - двусторонняя

### Синхронизация помещений
- `POST /integrations/pyrus/sync-rooms` - Pyrus → CRM
- `POST /integrations/pyrus/sync-rooms-to-pyrus` - CRM → Pyrus
- `POST /integrations/pyrus/sync-rooms-bidirectional` - двусторонняя

### Обнаружение конфликтов
- `GET /integrations/pyrus/detect-conflicts` - обнаружить конфликты (для уже связанных объектов)
- `POST /integrations/pyrus/sync-with-resolution` - синхронизация с разрешением конфликтов

## Технические детали

### Алгоритм Levenshtein distance

Вычисляет минимальное количество операций (вставка, удаление, замена) для преобразования одной строки в другую.

**Пример:**
- "акция" → "акция1": 1 операция (вставка "1") → расстояние = 1
- Максимальная длина = 6
- Схожесть = 1 - (1/6) = 0.833 = **83.3%**

### Оптимизация производительности

- Fuzzy matching выполняется **только если** не найдено точное совпадение
- Для больших справочников (>1000 записей) можно оптимизировать через индексацию или кэширование
