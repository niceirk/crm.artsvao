# Исправления двусторонней синхронизации с Pyrus

## Проблемы, которые были устранены:

### 1. Создание дублей вместо обновления
**Проблема:** При изменении объекта в CRM при синхронизации создавался дубль
**Причина:** Поиск объектов происходил только по названию, без использования уникального идентификатора

### 2. Отсутствие реального обновления данных
**Проблема:** При синхронизации счётчики `updated` увеличивались, но данные не обновлялись
**Причина:** В коде присутствовал только инкремент счётчика без вызова методов обновления

### 3. Отсутствие полей для связи с Pyrus
**Проблема:** Невозможно было однозначно сопоставить объекты между системами
**Причина:** В моделях `Room` и `EventType` отсутствовали поля для хранения Pyrus ID

## Внесенные изменения:

### 1. Схема базы данных (prisma/schema.prisma)
Добавлены поля `pyrusId` в модели:
- `Room.pyrusId` - уникальный идентификатор помещения в Pyrus
- `EventType.pyrusId` - уникальный идентификатор типа мероприятия в Pyrus

```prisma
model Room {
  // ...
  pyrusId      String?       @unique @map("pyrus_id")
  // ...
}

model EventType {
  // ...
  pyrusId     String?  @unique @map("pyrus_id")
  // ...
}
```

### 2. Миграция БД
Создана и применена миграция: `20251117193039_add_pyrus_id_to_rooms_and_event_types`

### 3. Исправлены методы синхронизации

#### syncRoomsFromCatalog (Pyrus → CRM)
**Было:**
- Поиск только по названию
- Только счётчик `updated++` без обновления данных

**Стало:**
- Поиск сначала по `pyrusId`, затем по названию
- Реальное обновление данных через `prisma.room.update()`
- Сохранение `pyrusId` при создании и обновлении

#### syncRoomsToPyrus (CRM → Pyrus)
**Было:**
- Поиск только по названию
- Только счётчик `updated++` без обновления в Pyrus

**Стало:**
- Поиск сначала по `pyrusId`, затем по названию
- Реальное обновление через `upsertCatalogItem()` при изменении названия
- Сохранение `pyrusId` в БД при создании новых элементов

#### syncEventTypesFromCatalog (Pyrus → CRM)
**Было:**
- Поиск только по названию
- Только счётчик `updated++` без обновления данных

**Стало:**
- Поиск сначала по `pyrusId`, затем по названию
- Реальное обновление данных через `prisma.eventType.update()`
- Сохранение `pyrusId` при создании и обновлении

#### syncEventTypesToPyrus (CRM → Pyrus)
**Было:**
- Поиск только по названию
- Только счётчик `updated++` без обновления в Pyrus

**Стало:**
- Поиск сначала по `pyrusId`, затем по названию
- Реальное обновление через `upsertCatalogItem()` при изменении названия
- Сохранение `pyrusId` в БД при создании новых элементов

## Как теперь работает синхронизация:

### Сценарий 1: Первая синхронизация (новые объекты)
1. Объект создаётся в одной из систем
2. При синхронизации он создаётся во второй системе
3. `pyrusId` сохраняется в БД для последующих синхронизаций

### Сценарий 2: Изменение существующего объекта
1. Объект изменяется в одной из систем (например, переименовывается)
2. При синхронизации система находит объект по `pyrusId`
3. Данные обновляются в другой системе
4. **Дубли не создаются!**

### Сценарий 3: Объект без pyrusId (старые данные)
1. При синхронизации система сначала пытается найти по `pyrusId`
2. Если не найдено, ищет по названию
3. Если найдено по названию - обновляет данные и сохраняет `pyrusId`
4. При следующей синхронизации уже используется `pyrusId`

## API endpoints для тестирования:

### Помещения (Rooms)
- `POST /integrations/pyrus/sync-rooms` - синхронизация Pyrus → CRM
- `POST /integrations/pyrus/sync-rooms-to-pyrus` - синхронизация CRM → Pyrus
- `POST /integrations/pyrus/sync-rooms-bidirectional` - двусторонняя синхронизация
- `GET /integrations/pyrus/preview-rooms-sync` - предпросмотр конфликтов

### Типы мероприятий (EventTypes)
- `POST /integrations/pyrus/sync-event-types` - синхронизация Pyrus → CRM
- `POST /integrations/pyrus/sync-event-types-to-pyrus` - синхронизация CRM → Pyrus
- `POST /integrations/pyrus/sync-event-types-bidirectional` - двусторонняя синхронизация
- `GET /integrations/pyrus/preview-event-types-sync` - предпросмотр конфликтов

## Что нужно протестировать:

1. **Создание нового объекта:**
   - Создать помещение/тип мероприятия в CRM
   - Запустить синхронизацию CRM → Pyrus
   - Проверить, что объект появился в Pyrus
   - Проверить, что в БД сохранился `pyrusId`

2. **Изменение существующего объекта:**
   - Изменить название помещения/типа в Pyrus
   - Запустить синхронизацию Pyrus → CRM
   - Проверить, что данные обновились в CRM (дубль не создался!)
   - Изменить название в CRM
   - Запустить синхронизацию CRM → Pyrus
   - Проверить, что данные обновились в Pyrus

3. **Двусторонняя синхронизация:**
   - Создать объект в CRM
   - Создать другой объект в Pyrus
   - Запустить двустороннюю синхронизацию
   - Проверить, что оба объекта появились в обеих системах

## Логирование:

Все операции синхронизации логируются с указанием:
- Создан или обновлён объект
- Название объекта
- Pyrus ID объекта

Пример логов:
```
[PyrusService] Обновлено помещение "Аудитория 1" (pyrusId: 12345)
[PyrusService] Создано помещение "Аудитория 2" (pyrusId: 12346)
[PyrusService] Обновлен тип мероприятия "Концерт" в справочнике Pyrus (ID: 67890)
```

## Рекомендации на будущее:

1. **Обработка конфликтов:** В будущем можно добавить UI для разрешения конфликтов, когда объект изменён одновременно в обеих системах
2. **Поле updatedAt:** Использовать для определения, какая версия данных более свежая
3. **Soft delete:** При удалении объекта в одной системе можно пометить его как удалённый, а не удалять физически
4. **Батч-операции:** Для больших объёмов данных можно оптимизировать через batch-запросы
